---
layout: post
title: Spring Security + Basic Auth + MD5Password encoding with salt all stored in
Cassandra
date: '2015-02-23T09:36:00.001-08:00'
author: Christopher Batey
tags:
- springboot
- spring-security
- spring
- cassandra
modified_time: '2015-02-23T09:36:27.896-08:00'
blogger_id: tag:blogger.com,1999:blog-4161315644722406995.post-2423893825266387830
blogger_orig_url: http://christopher-batey.blogspot.com/2015/02/spring-security-basic-auth-md5password.html
---

I've just put together a simple Spring boot application that has REST endpoints secured by basic auth &nbsp;with the users stored in Cassandra. I want the application to be completely stateless and will assume access is over HTTPS.
<br/>
<br/>I found it surprisingly difficult to plug all this together with Java config, there are very few complete examples so I ended up spending more time looking at the Spring source than I expected. Ah well that just confirms my love of using open source libraries and frameworks.
<br/><br/>Essentially you need an extension of the&nbsp;<span
        style="background-color: white; color: #a9b7c6; font-family: Menlo;"><span style="font-size: x-small;">WebSecurityConfigurerAdapter</span></span>
<span style="background-color: white; color: #795da3; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.7999992370605px; white-space: pre;">&nbsp;</span>class where you can programatically add your own&nbsp;
<span style="background-color: white; color: #a9b7c6; font-family: Menlo;"><span style="font-size: x-small;">UserDetailsService</span></span>.
<br/><br/>Here's my example, I'll explain it below.<br/><br/>
<script src="https://gist.github.com/chbatey/3a6e3a13ee2bfc02ccba.js"></script>
<br/>Line 11: I've injected the MD5PasswordEncoder as I also use in the code that handles the creation of users in the database.
<br/><br/>Line 14-22: Here is where we configure our custom&nbsp;<span
        style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">UserDetailsService&nbsp;</span>which I'll show later. We don't want to store user's passwords directly so we use the built in
<span style="color: #a9b7c6; font-family: Menlo; font-size: x-small;"><span style="background-color: white;">MD5PasswordEncoder</span></span>. Just using a one way hash isn't&nbsp;good enough as people can break this with reverse lookup tables so we also want to sprinkle in some salt. Our implementation of the&nbsp;
<span style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">UserDetailsService </span>will have a field called Salt and we use the&nbsp;
<span style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">ReflectiveSaltSource&nbsp;</span>to pick it up. Given how common salting passwords is I was surprised there wasn't a separate interface where this was explicit, but ah well.
<br/>
<br/>Line 25-34: Here we define what type of security we want, we tell Spring security to be stateless so it doesn't try and store anything in the container's session store. Then we enable BasicAuth and define the URLs we want to be authorised. The API for creating users is not authorised for obvious reasons.
<br/><br/>Next we want to build an implementation of the&nbsp;<span
        style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">UserDetailsService</span>&nbsp;interface that checks Cassandra.
<br/><br/>I won't go through the Cassandra code in the blog but just assume we have a DAO with the following interface:
<br/><br/>
<script src="https://gist.github.com/chbatey/d11a4a27d729c5241814.js"></script>
<br/>If you're interested in the Cassandra code then checkout the while project from GitHub.<br/>
<br/>With that interface our&nbsp;<span
        style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">UserDetailsService </span>looks like this:
<br/><br/>
<script src="https://gist.github.com/chbatey/e288d7431dc1a2f84ebb.js"></script>
<br/>Here we use the awesome Optional&nbsp;+ Lambda to throw if the user doesn't exist. Our DAO interface doesn't use Runtime exceptions as I like type systems, but this is a nice pattern to convert between a Optional and a library expecting exceptions.
<br/><br/>The UserWithSalt is an extension of the Spring's User, with one extra field that the&nbsp;<span
        style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">ReflectiveSaltSource </span>will pick up for salting passwords.
<br/><br/>
<script src="https://gist.github.com/chbatey/1d74914ee345e51a6163.js"></script>
<br/>That's pretty much it, when a request comes in Spring security will check if the path is authorised, if it is it will get the user details from our&nbsp;
<span style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">UserDetailsService </span>and check the password my using the&nbsp;
<span style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">ReflectiveSaltSource </span>and&nbsp;
<span style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">MD5PasswordEncoder</span>. So our database only has the MD5 password and the salt used to generate it. The salt is self is generated using the Java&nbsp;
<span style="background-color: white; color: #a9b7c6; font-family: Menlo; font-size: x-small;">SecureRandom</span>&nbsp;when users are created.
<br/><br/>Full source code is at <a
        href="https://github.com/chbatey/killrauction">GitHub</a> and I've created the branch blog-spring-security in case you're reading this in the future and it has all changed!
<br/><br/><br/><br/>